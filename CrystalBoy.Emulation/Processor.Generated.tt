<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="$(SolutionDir)CrystalBoy.Core.OpcodeTableGenerator\$(OutDir)OpcodeTableGenerator.dll" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="CrystalBoy.Core" #>
<#@ import namespace="CrystalBoy.Core.OpcodeTableGenerator" #>
<#@ output extension=".cs" #>
<# InitializeTemplateDictionary(); #>
#region Copyright Notice
// This file is part of CrystalBoy.
// Copyright © 2008-2011 Fabien Barbier
// 
// CrystalBoy is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// CrystalBoy is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
#endregion

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:<#= System.Runtime.InteropServices.RuntimeEnvironment.GetSystemVersion() #>
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Text;

namespace CrystalBoy.Emulation
{
	partial class Processor
	{
		public bool Emulate(bool finishFrame)
		{
			// Register variables, cloned here for efficiency (maybe it's an error, but it is easy to remove if needed)
			byte a, f, b, c, d, e, h, l, opcode;
			ushort sp, pc;
			bool ime;

			// Temporary result variable
			int temp;

			// Last instruction cycle count
			int cycleCount;

			// Temporary variables used internally for bus indirect operations
			byte __temp8;
			ushort __temp16, __tempHL;

			// Quickly exit the routine if the CPU crashed
			if (status == ProcessorStatus.Crashed) return true;

			// Clone the register values into local variables
			a = A; f = F; b = B; c = C; d = D; e = E; h = H; l = L;
			sp = SP; pc = PC;

			ime = InterruptMasterEnable;

			// Initialize the count at 0 to please the compiler :(
			cycleCount = 0;

			try
			{
				do
				{
					// Check for pending interrupts
					if (ime && (temp = bus.EnabledInterrupts & bus.RequestedInterrupts) != 0)
					{
						// Push PC on the stack
						bus.WriteByte(--sp, (byte)(pc >> 8));
						bus.WriteByte(--sp, (byte)pc);
						// Disable interrupts
						ime = false;
						// Set PC to new value acording to requested interrupts
						if ((temp & 0x01) != 0)
						{
							bus.InterruptHandled(0x01);
							pc = 0x0040;
						}
						else if ((temp & 0x02) != 0)
						{
							bus.InterruptHandled(0x02);
							pc = 0x0048;
						}
						else if ((temp & 0x04) != 0)
						{
							bus.InterruptHandled(0x04);
							pc = 0x0050;
						}
						else if ((temp & 0x08) != 0)
						{
							bus.InterruptHandled(0x08);
							pc = 0x0058;
						}
						else if ((temp & 0x10) != 0)
						{
							bus.InterruptHandled(0x10);
							pc = 0x0060;
						}
						cycleCount = 20; // I don't know the exact interrupt timing but I read somewhere it is 20, so instead of 4 i put 20 here...
						goto HandleBreakpoints;
					}

					opcode = bus[pc];

					if (!skipPcIncrement) pc++;
					else skipPcIncrement = false;

					switch (opcode)
					{
<#
for (int i = 0; i <= 255; i++)
{
	OpcodeInfo opcodeInfo;
	
	if (i == 0xCB)
	{
#>
						case 0xCB: /* Extended opcodes */
							opcode = bus[pc++];

							switch (opcode)
							{
<#
		for (int j = 0; j <= 255; j++)
		{
			opcodeInfo = Utility.GetExtendedOpcodeInfo((byte)j);
#>
								case /* 0xCB */ 0x<#= j.ToString("X2") #>: /* <#= GetOpcodeString(opcodeInfo) #> */
<#
			PushIndent("\t\t\t\t\t\t\t\t\t");
			WriteOpcodeStub(opcodeInfo);
			PopIndent();
#>
									break;
<#
		}
#>
							}
							break;
<#
	}
	else
	{
		opcodeInfo = Utility.GetOpcodeInfo((byte)i);
		
		if (opcodeInfo.Operation != Operation.Invalid)
		{
#>
						case 0x<#= i.ToString("X2") #>: /* <#= GetOpcodeString(opcodeInfo) #> */
<#
			PushIndent("\t\t\t\t\t\t\t");
			WriteOpcodeStub(opcodeInfo);
			PopIndent();
#>
							break;
<#
		}
	}
}
#>
						/* Invalid Opcodes */
<#
for (int i = 0; i < 255; i++)
{
	OpcodeInfo opcodeInfo;
	
	opcodeInfo = Utility.GetOpcodeInfo((byte)i);
	
	if (i != 0xCB && opcodeInfo.Operation == Operation.Invalid)
	{
#>
						case 0x<#= i.ToString("X2") #>:
<#
	}
}
#>
							status = ProcessorStatus.Crashed;
							pc--; // Revert changes to PC
							return true;
					}

					if (enableInterruptDelay != 0 && --enableInterruptDelay == 0) ime = true;
					
				HandleBreakpoints:
#if WITH_DEBUGGING
					// Handle breakpoints after running at least one instruction
					if (bus.BreakpointCount > 0) // Check for breakpoints only if there are some
						if (bus.IsBreakPoint(pc))
							return false; // Break when a breakpoint is encountered
#else
					;
#endif
				} while (bus.AddVariableCycles(cycleCount) && finishFrame);

				return finishFrame; // Emulated with success
			}
			finally
			{
				// Save the local register values
				A = a; F = f; B = b; C = c; D = d; E = e; H = h; L = l;
				SP = sp; PC = pc;

				InterruptMasterEnable = ime;
			}
		}
	}
}
<#+

private delegate void Template(string op1, string op2);

private Dictionary<string, Template> templateDictionary;

private void InitializeTemplateDictionary()
{
	if (templateDictionary != null) return;

	var dictionary = new Dictionary<string, Template>();
	
	var methods = this.GetType().GetMethods(BindingFlags.NonPublic | BindingFlags.Instance);
	
	foreach (var method in methods)
		if (method.Name.EndsWith("_Template"))
			dictionary.Add(method.Name.Substring(0, method.Name.Length - 9), Delegate.CreateDelegate(typeof(Template), this, method) as Template);
	
	templateDictionary = dictionary;
}

private void CallTemplate(string templateName, string op1, string op2)
{
	Template template;

	if (templateDictionary.TryGetValue(templateName, out template))
		template(op1, op2);
}

private static string GetOpcodeString(OpcodeInfo opcodeInfo)
{
	return opcodeInfo.FormatString.Replace("${0:X2}", "N").Replace("${0:X4}", "N").Replace("{0:X2}", "00+N");
}

private void WriteOpcodeStub(OpcodeInfo opcodeInfo)
{
	string operand1, operand2;

	if (opcodeInfo.Operation == Operation.Ld && opcodeInfo.SecondOperand == Operand.Sp)
	{
		CallTemplate("LdSp", null, null);
		return;
	}
	else
	{
		// Only load the first operand for arithmetic and logical operations (Also for PUSH)
		if (opcodeInfo.Operation == Operation.Inc ||
			opcodeInfo.Operation == Operation.Dec ||
			opcodeInfo.Operation == Operation.Add ||
			opcodeInfo.Operation == Operation.Adc ||
			opcodeInfo.Operation == Operation.Sub ||
			opcodeInfo.Operation == Operation.Sbc ||
			opcodeInfo.Operation == Operation.And ||
			opcodeInfo.Operation == Operation.Xor ||
			opcodeInfo.Operation == Operation.Or ||
			opcodeInfo.Operation == Operation.Cp ||
			opcodeInfo.Operation == Operation.Rlc ||
			opcodeInfo.Operation == Operation.Rrc ||
			opcodeInfo.Operation == Operation.Rl ||
			opcodeInfo.Operation == Operation.Rr ||
			opcodeInfo.Operation == Operation.Sla ||
			opcodeInfo.Operation == Operation.Sra ||
			opcodeInfo.Operation == Operation.Swap ||
			opcodeInfo.Operation == Operation.Srl ||
			opcodeInfo.Operation == Operation.Push ||
			opcodeInfo.Operation == Operation.Jr ||
			opcodeInfo.Operation == Operation.Jp ||
			opcodeInfo.Operation == Operation.Call)
		{
			operand1 = GetOperandLoadStub(opcodeInfo.FirstOperand);
			if (operand1 != null && operand1.Length > 0)
			{
#>
<#= operand1 #>
<#+
			}
		}

		operand2 = GetOperandLoadStub(opcodeInfo.SecondOperand);
		if (operand2 != null && operand2.Length > 0)
			{
#>
<#= operand2 #>
<#+
			}

		operand1 = GetOperandString(opcodeInfo.FirstOperand, opcodeInfo.EmbeddedValue);
		operand2 = GetOperandString(opcodeInfo.SecondOperand, opcodeInfo.EmbeddedValue);

		if (opcodeInfo.Operation == Operation.Add)
			CallTemplate(opcodeInfo.FirstOperand == Operand.Sp ? "AddS" : opcodeInfo.FirstOperand == Operand.Hl ? "Add16" : "Add8", operand1, operand2);
		else if (opcodeInfo.Operation == Operation.Inc)
		{
			CallTemplate
			(
				opcodeInfo.FirstOperand == Operand.Bc ||
				opcodeInfo.FirstOperand == Operand.De ||
				opcodeInfo.FirstOperand == Operand.Hl ||
				opcodeInfo.FirstOperand == Operand.Sp ?
					"Inc16" :
					"Inc8",
				operand1, operand2
			);
		}
		else if (opcodeInfo.Operation == Operation.Dec)
		{
			CallTemplate
			(
				opcodeInfo.FirstOperand == Operand.Bc ||
				opcodeInfo.FirstOperand == Operand.De ||
				opcodeInfo.FirstOperand == Operand.Hl ||
				opcodeInfo.FirstOperand == Operand.Sp ?
					"Dec16" :
					"Dec8",
				operand1, operand2
			);
		}
		else if ((opcodeInfo.Operation == Operation.Jr ||
			opcodeInfo.Operation == Operation.Jp ||
			opcodeInfo.Operation == Operation.Call) &&
			opcodeInfo.SecondOperand != Operand.None ||
			opcodeInfo.Operation == Operation.Ret &&
			opcodeInfo.FirstOperand != Operand.None)
		{
#>
if (<#= operand1 #>)
{
<#+
			PushIndent("\t");
			CallTemplate(opcodeInfo.Operation.ToString(), operand2, null);
			PopIndent();
#>
	cycleCount = <#= opcodeInfo.BaseCycleCount + opcodeInfo.ConditionalCycleCount #>;
}
else cycleCount = <#= opcodeInfo.BaseCycleCount #>;
<#+
			return;
		}
		else if (opcodeInfo.Operation == Operation.Ldi || opcodeInfo.Operation == Operation.Ldd)
			CallTemplate("Ld", operand1, operand2);
		else if (opcodeInfo.Operation == Operation.Ld && opcodeInfo.SecondOperand == Operand.StackRelative)
			CallTemplate("LdAddS", operand1, operand2);
		else
			CallTemplate(opcodeInfo.Operation.ToString(), operand1, operand2);

		if (opcodeInfo.Operation == Operation.Set
			|| opcodeInfo.Operation == Operation.Res)
		{
			operand2 = GetOperandStoreStub(opcodeInfo.SecondOperand);
			if (operand2 != null && operand2.Length > 0)
			{
#>
<#= operand2 #>
<#+
			}
		}
		else if (opcodeInfo.Operation != Operation.Push)
		{
			operand1 = GetOperandStoreStub(opcodeInfo.FirstOperand);
			if (operand1 != null && operand1.Length > 0)
			{
#>
<#= operand1 #>
<#+
			}
		}

		if (opcodeInfo.Operation == Operation.Ldi)
		{
#>
if (++l == 0) h++;
<#+
		}
		else if (opcodeInfo.Operation == Operation.Ldd)
		{
#>
if (l-- == 0) h--;
<#+
		}
	}

	WriteFixedFlags(opcodeInfo.AffectedFlags & opcodeInfo.SetFlags, opcodeInfo.AffectedFlags & opcodeInfo.ClearFlags);

	if (opcodeInfo.Operation != Operation.Halt)
	{
#>
cycleCount = <#= opcodeInfo.BaseCycleCount #>;
<#+
	}
}
		
private void WriteFixedFlags(Flags setFlags, Flags clearFlags)
{
	if ((setFlags | clearFlags) == 0) return;

	System.Diagnostics.Debug.Assert((setFlags & clearFlags) == 0);

	if ((byte)clearFlags == 0)
	{
#>
f |= 0x<#= ((int)setFlags).ToString("X2") #>;
<#+
	}
	else if ((byte)setFlags == 0)
	{
#>
f &= 0x<#= ((~(int)clearFlags) & 0xF0).ToString("X2") #>;
<#+
	}
	else
	{
#>
f = (byte)(f & 0x<#= ((~(int)clearFlags & 0xF0)).ToString("X2") #> | 0x<#= ((byte)setFlags).ToString("X2") #>);
<#+
	}
}
		
private static string GetOperandString(Operand operand, byte embeddedValue)
{
	switch (operand)
	{
		case Operand.A: return "a";
		case Operand.B: return "b";
		case Operand.C: return "c";
		case Operand.D: return "d";
		case Operand.E: return "e";
		case Operand.H: return "h";
		case Operand.L: return "l";

		case Operand.Af: return "__temp16";
		case Operand.Bc: return "__temp16";
		case Operand.De: return "__temp16";
		case Operand.Hl: return "__tempHL";
		case Operand.Sp: return "sp";

		case Operand.Embedded: return embeddedValue.ToString();

		// Memory operations are 8 bit most of the time
		case Operand.Memory:
		case Operand.MemoryBc:
		case Operand.MemoryDe:
		case Operand.MemoryHl:
		case Operand.BytePort:
		case Operand.RegisterPort:
		case Operand.Byte: return "__temp8";

		// Some operands have to be extended to 16 bits for easier manipulation
		case Operand.SByte:
		case Operand.Word: return "__temp16";
		case Operand.StackRelative: return "sp";

		case Operand.NotZero: return "((f & ZFlag) == 0)";
		case Operand.Zero: return "((f & ZFlag) != 0)";
		case Operand.NotCarry: return "((f & CFlag) == 0)";
		case Operand.Carry: return "((f & CFlag) != 0)";

		default: return null;
	}
}

private static string GetOperandLoadStub(Operand operand)
{
	switch (operand)
	{
		case Operand.Af: return "__temp16 = (ushort)((a << 8) | f);";
		case Operand.Bc: return "__temp16 = (ushort)((b << 8) | c);";
		case Operand.De: return "__temp16 = (ushort)((d << 8) | e);";
		case Operand.Hl: return "__tempHL = (ushort)((h << 8) | l);";

		case Operand.Memory: return "__temp8 = bus[bus[pc++], bus[pc++]];";
		case Operand.MemoryBc: return "__temp8 = bus[c, b];";
		case Operand.MemoryDe: return "__temp8 = bus[e, d];";
		case Operand.MemoryHl: return "__temp8 = bus[l, h];";
		case Operand.BytePort: return "__temp8 = bus.ReadPort(bus[pc++]);";
		case Operand.RegisterPort: return "__temp8 = bus.ReadPort(c);";
		case Operand.Byte: return "__temp8 = bus[pc++];";

		case Operand.SByte: return "__temp16 = (ushort)(sbyte)bus[pc++];";
		case Operand.Word: return "__temp16 = (ushort)(bus[pc++] | (bus[pc++] << 8));";

		default: return null;
	}
}

private static string GetOperandStoreStub(Operand operand)
{
	switch (operand)
	{
		case Operand.Af: return "a = (byte)(__temp16 >> 8); f = (byte)(__temp16 & 0x0F0);";
		case Operand.Bc: return "b = (byte)(__temp16 >> 8); c = (byte)(__temp16);";
		case Operand.De: return "d = (byte)(__temp16 >> 8); e = (byte)(__temp16);";
		case Operand.Hl: return "h = (byte)(__tempHL >> 8); l = (byte)(__tempHL);";

		case Operand.Memory: return "bus[bus[pc++], bus[pc++]] = __temp8;";
		case Operand.MemoryBc: return "bus[c, b] = __temp8;";
		case Operand.MemoryDe: return "bus[e, d] = __temp8;";
		case Operand.MemoryHl: return "bus[l, h] = __temp8;";
		case Operand.BytePort: return "bus.WritePort(bus[pc++], __temp8);";
		case Operand.RegisterPort: return "bus.WritePort(c, __temp8);";

		default: return null;
	}
}

#region Templates

private void Adc_Template(string operand1, string operand2)
{
#>
if ((f & CFlag) != 0)
{
	temp = <#= operand1 #> + <#= operand2 #> + 1;
	f = (byte)(((<#= operand1 #> & 0xF) + (<#= operand2 #> & 0xF) > 0xE ? HFlag : 0) | (temp > 0xFF ? CFlag : 0) | ((<#= operand1 #> = (byte)temp) == 0 ? ZFlag : 0));
}
else
{
	temp = <#= operand1 #> + <#= operand2 #>;
	f = (byte)(((<#= operand1 #> & 0xF) + (<#= operand2 #> & 0xF) > 0xF ? HFlag : 0) | (temp > 0xFF ? CFlag : 0) | ((<#= operand1 #> = (byte)temp) == 0 ? ZFlag : 0));
}
<#+
}

private void Add16_Template(string operand1, string operand2)
{
#>
temp = <#= operand1 #> + <#= operand2 #>;
f = (byte)(f & 0x80 | ((<#= operand1 #> & 0xFFF) + (<#= operand2 #> & 0xFFF) > 0xFFF ? HFlag : 0) | (temp > 0xFFFF ? CFlag : 0));
<#= operand1 #> = (ushort)temp;
<#+
}

private void AddS_Template(string operand1, string operand2)
{
#>
temp = <#= operand1 #> + <#= operand2 #>;
f = (byte)((((<#= operand1 #> ^ <#= operand2 #> ^ temp) & 0x10) != 0 ? HFlag : 0) | (((<#= operand1 #> ^ <#= operand2 #> ^ temp) & 0x100) != 0 ? CFlag : 0));
<#= operand1 #> = (ushort)temp;
<#+
}

private void Add8_Template(string operand1, string operand2)
{
#>
temp = <#= operand1 #> + <#= operand2 #>;
f = (byte)(((<#= operand1 #> & 0xF) + (<#= operand2 #> & 0xF) > 0xF ? HFlag : 0) | (temp > 0xFF ? CFlag : 0) | ((<#= operand1 #> = (byte)temp) == 0 ? ZFlag : 0));
<#+
}

private void And_Template(string operand1, string operand2)
{
	if (operand1 == operand2)
	{
#>
f = (byte)(<#= operand1 #> == 0 ? f | ZFlag : f & NotZFlag);
<#+
	}
	else
	{
#>
f = (byte)((<#= operand1 #> &= <#= operand2 #>) == 0 ? f | ZFlag : f & NotZFlag);
<#+
	}
}

private void Bit_Template(string operand1, string operand2)
{
#>
f = (byte)((<#= operand2 #> & 0x<#= (1 << int.Parse(operand1)).ToString("X2") #>) == 0 ? f | ZFlag : f & NotZFlag);
<#+
}

private void Call_Template(string operand1, string operand2)
{
#>
bus[--sp] = (byte)(pc >> 8);
bus[--sp] = (byte)pc;
pc = <#= operand1 #>;
<#+
}

private void Ccf_Template(string operand1, string operand2)
{
#>
f ^= CFlag;
<#+
}

private void Cp_Template(string operand1, string operand2)
{
	if (operand1 == operand2)
	{
#>
f = 0xC0;
<#+
	}
	else
	{
#>
f = (byte)(((<#= operand1 #> & 0xF) < (<#= operand2 #> & 0xF) ? HFlag : 0) | (<#= operand1 #> < <#= operand2 #> ? CFlag : 0) | NFlag | (<#= operand1 #> == <#= operand2 #> ? ZFlag : 0));
<#+
	}
}

private void Cpl_Template(string operand1, string operand2)
{
#>
a = (byte)~a;
<#+
}

private void Daa_Template(string operand1, string operand2)
{
#>
if ((f & NFlag) != 0)
{
	if ((f & HFlag) != 0) a -= 0x06;
	if ((f & CFlag) != 0) a -= 0x60;
}
else
{
	if ((f & CFlag) != 0 || a > 0x99)
	{
		a += (f & HFlag) != 0 || (a & 0x0F) > 0x09 ? (byte)0x66 : (byte)0x60;
		f |= CFlag;
	}
	else if ((f & HFlag) != 0 || (a & 0x0F) > 0x09) a += 0x06;
}
f = (byte)(a == 0 ? f | ZFlag : f & NotZFlag);
<#+
}

private void Dec16_Template(string operand1, string operand2)
{
#>
<#= operand1 #>--;
<#+
}

private void Dec8_Template(string operand1, string operand2)
{
#>
<#= operand1 #>--;
f = (byte)(f & CFlag | (<#= operand1 #> != 0 ? (<#= operand1 #> & 0xF) != 0xF ? 0 : HFlag : ZFlag) | NFlag);
<#+
}

private void Di_Template(string operand1, string operand2)
{
#>
ime = false;
<#+
}

private void Ei_Template(string operand1, string operand2)
{
#>
// Will enable interrupts one instruction later, or directly after this one if EI has been repeated.
if (enableInterruptDelay == 0) enableInterruptDelay = 2;
<#+
}

private void Halt_Template(string operand1, string operand2)
{
#>
if (enableInterruptDelay > 0) pc--; // Case where HALT directly follows EI
// Still need a better emulation of the HALT opcode, but this one will work for now
else if (ime || bus.EnabledInterrupts != 0)
{
	bus.AddVariableCycles(4); // Add the 4 cycles now… In order to adjust interrupts
	if ((bus.EnabledInterrupts & bus.RequestedInterrupts) == 0)
	{
		status = ProcessorStatus.Halted;
		cycleCount = bus.WaitForInterrupts();
		if (cycleCount < 0) return false;
		if ((cycleCount & 0x3) != 0) cycleCount += 4 - (cycleCount & 0x3); // Keep the cycle count as a multiple of 4
		status = ProcessorStatus.Running;
	}
	else cycleCount = 0;
}
<#+
}

private void Inc16_Template(string operand1, string operand2)
{
#>
<#= operand1 #>++;
<#+
}

private void Inc8_Template(string operand1, string operand2)
{
#>
<#= operand1 #>++;
f = (byte)(f & CFlag | (<#= operand1 #> != 0 ? (<#= operand1 #> & 0xF) == 0 ? HFlag : 0 : ZFlag | HFlag));
<#+
}

private void Jp_Template(string operand1, string operand2)
{
#>
pc = <#= operand1 #>;
<#+
}

private void Jr_Template(string operand1, string operand2)
{
#>
pc += <#= operand1 #>;
<#+
}

private void Ld_Template(string operand1, string operand2)
{
	if (operand1 != operand2)
	{
#>
<#= operand1 #> = <#= operand2 #>;
<#+
	}
}

private void LdAddS_Template(string operand1, string operand2)
{
#>
__temp16 = (ushort)(sbyte)bus[pc++];
temp = <#= operand2 #> + __temp16;
f = (byte)((((<#= operand2 #> ^ __temp16 ^ temp) & 0x10) != 0 ? HFlag : 0) | (((<#= operand2 #> ^ __temp16 ^ temp) & 0x100) != 0 ? CFlag : 0));
<#= operand1 #> = (ushort)temp;
<#+
}

private void LdSp_Template(string operand1, string operand2)
{
#>
__temp16 = (ushort)(bus[pc++] | (bus[pc++] << 8));
bus[__temp16++] = (byte)(sp);
bus[__temp16] = (byte)(sp >> 8);
<#+
}

private void Or_Template(string operand1, string operand2)
{
	if (operand1 == operand2)
	{
#>
f = (byte)(<#= operand1 #> == 0 ? f | ZFlag : f & NotZFlag);
<#+
	}
	else
	{
#>
f = (byte)((<#= operand1 #> |= <#= operand2 #>) == 0 ? f | ZFlag : f & NotZFlag);
<#+
	}
}

private void Pop_Template(string operand1, string operand2)
{
#>
<#= operand1 #> = (ushort)(bus[sp++] | (bus[sp++] << 8));
<#+
}

private void Push_Template(string operand1, string operand2)
{
#>
bus[--sp] = (byte)(<#= operand1 #> >> 8);
bus[--sp] = (byte)<#= operand1 #>;
<#+
}

private void Res_Template(string operand1, string operand2)
{
#>
<#= operand2 #> &= 0x<#= (~(1 << int.Parse(operand1)) & 0xFF).ToString("X2") #>;
<#+
}

private void Ret_Template(string operand1, string operand2)
{
#>
pc = (ushort)(bus[sp++] | (bus[sp++] << 8));
<#+
}

private void Reti_Template(string operand1, string operand2)
{
#>
pc = (ushort)(bus[sp++] | (bus[sp++] << 8));
ime = true;
<#+
}

private void Rl_Template(string operand1, string operand2)
{
#>
f = (byte)(((<#= operand1 #> & 0x80) != 0 ? CFlag : 0) | ((<#= operand1 #> = (byte)((f & CFlag) != 0 ? (<#= operand1 #> << 1) | 0x01 : <#= operand1 #> << 1)) == 0 ? ZFlag : 0));
<#+
}

private void Rla_Template(string operand1, string operand2)
{
#>
if ((f & CFlag) != 0)
{
	f = (byte)((a & 0x80) != 0 ? CFlag : 0);
	a = (byte)((a << 1) | 0x01);
}
else
{
	f = (byte)((a & 0x80) != 0 ? CFlag : 0);
	a <<= 1;
}
<#+
}

private void Rlc_Template(string operand1, string operand2)
{
#>
f = (byte)(((<#= operand1 #> & 0x80) != 0 ? CFlag : 0) | ((<#= operand1 #> = (byte)((<#= operand1 #> & 0x80) != 0 ? (<#= operand1 #> << 1) | 0x01 : <#= operand1 #> << 1)) == 0 ? ZFlag : 0));
<#+
}

private void Rlca_Template(string operand1, string operand2)
{
#>
if ((a & 0x80) != 0)
{
	f = CFlag;
	a = (byte)((a << 1) | 0x01);
}
else
{
	f = 0;
	a <<= 1;
}
<#+
}

private void Rr_Template(string operand1, string operand2)
{
#>
f = (byte)(((<#= operand1 #> & 0x01) != 0 ? CFlag : 0) | ((<#= operand1 #> = (byte)((f & CFlag) != 0 ? (<#= operand1 #> >> 1) | 0x80 : <#= operand1 #> >> 1)) == 0 ? ZFlag : 0));
<#+
}

private void Rra_Template(string operand1, string operand2)
{
#>
if ((f & CFlag) != 0)
{
	f = (byte)((a & 0x01) != 0 ? CFlag : 0);
	a = (byte)((a >> 1) | 0x80);
}
else
{
	f = (byte)((a & 0x01) != 0 ? CFlag : 0);
	a >>= 1;
}
<#+
}

private void Rrc_Template(string operand1, string operand2)
{
#>
f = (byte)(((<#= operand1 #> & 0x01) != 0 ? CFlag : 0) | ((<#= operand1 #> = (byte)((<#= operand1 #> & 0x01) != 0 ? (<#= operand1 #> >> 1) | 0x80 : <#= operand1 #> >> 1)) == 0 ? ZFlag : 0));
<#+
}

private void Rrca_Template(string operand1, string operand2)
{
#>
if ((a & 0x01) != 0)
{
	f = CFlag;
	a = (byte)((a >> 1) | 0x80);
}
else
{
	f = 0;
	a >>= 1;
}
<#+
}

private void Rst_Template(string operand1, string operand2)
{
#>
bus[--sp] = (byte)(pc >> 8);
bus[--sp] = (byte)pc;
pc = <#= operand1 #>;
<#+
}

private void Sbc_Template(string operand1, string operand2)
{
	if (operand1 == operand2)
	{
#>
if ((f & CFlag) != 0)
{
	<#= operand1 #> = 0xFF;
	f = 0x70;
}
else
{
	<#= operand1 #> = 0;
	f = 0xC0;
}
<#+
	}
	else
	{
#>
if ((f & CFlag) != 0) f = (byte)(((<#= operand1 #> & 0xF) - (<#= operand2 #> & 0xF) < 1 ? HFlag : 0) | (<#= operand1 #> - <#= operand2 #> < 1 ? CFlag : 0) | NFlag | ((<#= operand1 #> = (byte)(<#= operand1 #> - <#= operand2 #> - 1)) == 0 ? ZFlag : 0));
else f = (byte)(((<#= operand1 #> & 0xF) < (<#= operand2 #> & 0xF) ? HFlag : 0) | (<#= operand1 #> < <#= operand2 #> ? CFlag : 0) | NFlag | ((<#= operand1 #> -= <#= operand2 #>) == 0 ? ZFlag : 0));
<#+
	}
}

private void Scf_Template(string operand1, string operand2) { }

private void Set_Template(string operand1, string operand2)
{
#>
<#= operand2 #> |= 0x<#= (1 << int.Parse(operand1)).ToString("X2") #>;
<#+
}

private void Sla_Template(string operand1, string operand2)
{
#>
f = (byte)(((<#= operand1 #> & 0x80) != 0 ? CFlag : 0) | ((<#= operand1 #> = (byte)(<#= operand1 #> << 1)) == 0 ? ZFlag : 0));
<#+
}

private void Sra_Template(string operand1, string operand2)
{
#>
f = (byte)(((<#= operand1 #> & 0x01) != 0 ? CFlag : 0) | ((<#= operand1 #> = (byte)((sbyte)<#= operand1 #> >> 1)) == 0 ? ZFlag : 0));
<#+
}

private void Srl_Template(string operand1, string operand2)
{
#>
f = (byte)(((<#= operand1 #> & 0x01) != 0 ? CFlag : 0) | ((<#= operand1 #> = (byte)(<#= operand1 #> >> 1)) == 0 ? ZFlag : 0));
<#+
}

private void Stop_Template(string operand1, string operand2)
{
#>
status = ProcessorStatus.Stopped;
cycleCount = bus.HandleProcessorStop();
if (cycleCount < 0)
	return false;
status = ProcessorStatus.Running;
<#+
}

private void Sub_Template(string operand1, string operand2)
{
	if (operand1 == operand2)
	{
#>
<#= operand1 #> = 0;
f = 0xC0;
<#+
	}
	else
	{
#>
f = (byte)(((<#= operand1 #> & 0xF) < (<#= operand2 #> & 0xF) ? HFlag : 0) | (<#= operand1 #> < <#= operand2 #> ? CFlag : 0) | NFlag | ((<#= operand1 #> -= <#= operand2 #>) == 0 ? ZFlag : 0));
<#+
	}
}

private void Swap_Template(string operand1, string operand2)
{
#>
f = (byte)((<#= operand1 #> = (byte)((<#= operand1 #> >> 4) | (<#= operand1 #> << 4))) == 0 ? ZFlag : 0);
<#+
}

private void Xor_Template(string operand1, string operand2)
{
	if (operand1 == operand2)
	{
#>
<#= operand1 #> = 0;
f |= ZFlag;
<#+
	}
	else
	{
#>
f = (byte)((<#= operand1 #> ^= <#= operand2 #>) == 0 ? f | ZFlag : f & NotZFlag);
<#+
	}
}

#endregion
#>